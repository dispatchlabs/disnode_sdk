<html>
  <body>
    <script src="../../dist/disjs.js"></script>
    <h1>DisJS Examples</h1>
    <script>
      DisJS.ENV = 'stage';
      
      new Promise((resolve, reject) => {
        console.log('--- ACCOUNT EXAMPLES ---\n');

        // Account is a constructor with no required inputs
        const temp = new DisJS.Account();
        // It can also accept any account fields; the most prominant being the privateKey
        const test = new DisJS.Account({name: 'NodeSDKTest', privateKey: '70dcae0f1020d5b35f2be2df6146b432be594407121ac7c8cb48540ecc5e7ede' });

        // Use account.init() to generate a private key
        temp.init();
        // Models output clean strings in logs and JSON.stringify
        console.log('Temp account:\n' + temp + '\n');

        // Account objects can send tokens to other accounts directly; returning the resulting Transaciton
        let tx = test.sendTokens(temp, 5);
        console.log('New "sendTokens" transaction:\n' + tx + '\n');

        // Calling "send" on the Transaction will return the original Promise (not re-send the tx)
        tx.send()
          .then(
            (ok) => {
              // Use 'whenStatusEquals' (returns a Promise) to wait for the transaction to finish
              tx.whenStatusEquals('Ok')
                .then(
                  (result) => {
                    console.log('Transaction result:\n' + JSON.stringify(result) + '\n');

                    // Reset
                    temp.sendTokens(test, 5).send()
                      .then(() => {
                        resolve();
                      })
                      .catch((e) => {
                        resolve();
                      });

                  }, (err) => {
                    console.log('Transaction result error:\n' + JSON.stringify(err) + '\n');
                  }
                );
            },
            (err) => {
              console.log('Transaction result error:\n' + JSON.stringify(err) + '\n');
            }
          );
      }).then(() => {
        return new Promise((resolve, reject) => {
          console.log('\n\n--- TRANSACTION EXAMPLES ---\n');

        // START SETUP

          console.log('Setting up...');
          // Account is a constructor with no required inputs
          const temp = new DisJS.Account();
          // It can also accept any account fields; the most prominant being the privateKey
          const test = new DisJS.Account({name: 'NodeSDKTest', privateKey: '70dcae0f1020d5b35f2be2df6146b432be594407121ac7c8cb48540ecc5e7ede' });

          // Use account.init() to generate a private key
          temp.init();

          // Account objects can send tokens to other accounts directly; returning the resulting Transaciton
          let tx = test.sendTokens(temp, 5);

          // Calling "send" on the Transaction will return the original Promise (not re-send the tx)
          tx.send()
            .then(
              (ok) => {
                // Use 'whenStatusEquals' (returns a Promise) to wait for the transaction to finish
                tx.whenStatusEquals('Ok')
                  .then(
                    (result) => {
                      
        // END SETUP

                      // Transactions may be created and executed directly
                      tx = new DisJS.Transaction({
                        from: temp,
                        to: test,
                        value: 5
                      });
                      console.log('New Transaction:\n' + tx + '\n');

                      // Transactions can also be sent directly, which returns a Promise
                      tx.send()
                        .then((result) => {
                          console.log('Transaction submission:\n' + JSON.stringify(result) + '\n');

                          // Use 'whenStatusEquals' (returns a Promise) to wait for the transaction to finish
                          tx.whenStatusEquals('Ok')
                            .then(
                              (result) => {
                                console.log('Transaction result:\n' + JSON.stringify(result) + '\n');

                                // Reset
                                temp.sendTokens(test, 5).send()
                                  .then(() => {
                                    resolve();
                                  })
                                  .catch((e) => {
                                    resolve();
                                  });

                              }, (err) => {
                                console.error('Transaction result:\n' + JSON.stringify(err) + '\n');
                              }
                            );
                        }, (err) => {
                          console.error('Transaction result:\n' + JSON.stringify(err) + '\n');
                        });


                    }, (err) => {
                      console.log('Setup failed!');
                      console.error(err);
                    }
                  );
              },
              (err) => {
                console.log('Setup failed!');
                console.error(err);
              }
            );
        });
      }).then(() => {
        return new Promise((resolve, reject) => {
          console.log('\n\n--- SMART CONTRACT EXAMPLES ---\n');

        // SETUP
          console.log('Setting up...');
          const tearDown = () => {
            temp.sendTokens(test, 5).send()
              .then(() => {
                resolve();
              })
              .catch((e) => {
                resolve();
              });
          };

          // Account is a constructor with no required inputs
          const temp = new DisJS.Account();
          // It can also accept any account fields; the most prominant being the privateKey
          const test = new DisJS.Account({name: 'NodeSDKTest', privateKey: '70dcae0f1020d5b35f2be2df6146b432be594407121ac7c8cb48540ecc5e7ede' });

          // Use account.init() to generate a private key
          temp.init();

          // Account objects can send tokens to other accounts directly; returning the resulting Transaciton
          let tx = test.sendTokens(temp, 5);

          // Calling "send" on the Transaction will return the original Promise (not re-send the tx)
          tx.send()
            .then(
              (ok) => {
                // Use 'whenStatusEquals' (returns a Promise) to wait for the transaction to finish
                tx.whenStatusEquals('Ok')
                  .then(
                    (result) => {

        // END SETUP
                      const abi = [
                          {
                            constant: true,
                            inputs: [
                              {
                                name:'y',
                                type: 'uint256'
                              }
                            ],
                            name: 'plusOne',
                            outputs: [
                              {
                                name: 'x',
                                type: 'uint256'
                              }
                            ],
                            payable: false,
                            stateMutability: 'pure',
                            type: 'function'
                          }
                        ];

                      // Accounts can create Smart Contracts using compiled values
                      const contract = test.createContract(
                        "6080604052348015600f57600080fd5b50609c8061001e6000396000f300608060405260043610603e5763ffffffff7c0100000000000000000000000000000000000000000000000000000000600035041663f5a6259f81146043575b600080fd5b348015604e57600080fd5b506058600435606a565b60408051918252519081900360200190f35b600101905600a165627a7a72305820d80420eaa03f38e6d95fdb138708115dae7b4761f6d00171874d7fa40de8a7680029",
                        abi
                      );
                      console.log('\nNew contract:\n' + contract + '\n');

                      // Calling "send" on the Transaction will return the original Promise (not re-send the tx)
                      contract.send()
                        .then(
                          (ok) => {
                            // Once a contract is created, it can be executed
                            contract
                              .whenStatusEquals('Ok')
                                .then((result) => {

                                  console.log('Contract creation result:\n' + JSON.stringify(result) + '\n');

                                  // Exection happens from the account, to the contract, along with the method and parameters
                                  const execute = test.executeContract(contract, 'plusOne', [1.0]);
                                  console.log('Contract execution:\n' + execute + '\n');
                                  execute
                                    .whenStatusEquals('Ok')
                                      .then((result) => {
                                        console.log('Contract execution result:\n' + JSON.stringify(result) + '\n');

                                        // Reset
                                        tearDown();

                                      }, (err) => {
                                        console.log('Contract execution result error:\n' + JSON.stringify(err) + '\n');
                                        // Reset
                                        tearDown();
                                      });

                                }, (err) => {
                                  console.log('Contract creation result error:\n' + JSON.stringify(err) + '\n');
                                  // Reset
                                  tearDown();
                                });
                          },
                          (err) => {
                            console.log('Contract creation result error:\n' + JSON.stringify(err) + '\n');
                          }
                        );


                    }, (err) => {
                      console.log('Setup failed!');
                      console.error(err);
                    }
                  );
              },
              (err) => {
                console.log('Setup failed!');
                console.error(err);
              }
            );
        });
      }).catch((e) => {
        console.error(e);
      });
    </script>
  </body>
</html>